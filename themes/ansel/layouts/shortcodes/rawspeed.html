{{/* Extract Libraw supported cameras from the .cpp file. They are declared as `"maker model",` */}}
{{ $libraw_cameras := slice }}
{{ with resources.GetRemote "https://raw.githubusercontent.com/LibRaw/LibRaw/refs/heads/master/src/tables/cameralist.cpp" }}
{{ $libraw_cameras = strings.FindRESubmatch `"(.+?)",` .Content }}
{{ end }}

{{/* Get Rawspeed XML camera database */}}
{{ $data := dict }}
{{ with resources.GetRemote "https://raw.githubusercontent.com/darktable-org/rawspeed/refs/heads/develop/data/cameras.xml" }}
{{ $data = . | transform.Unmarshal }}
{{ end }}

{{/*
  Build the unique set of maker/model.
  This is because each RAW mode/format is recorded as a new <camera> object,
  but we want one object per camera where modes/formats are concatenated.
*/}}
{{ $cameras := dict }}
{{ with $data.Camera }}
  {{ range . }}
    {{ $maker := (index .ID "-make") | default (index . "-make") }}
    {{ $model := (index .ID "-model") | default (index . "-model") }}
    {{/*
      Monkey business: some camera models have maker brand in their name, some don't.
      Ensure all models have no maker, and makermodel always have both
      */}}
    {{ $model = replaceRE $maker "" $model }}
    {{ $makermodel := printf "%s %s" $maker $model }}

    {{ $previous := index $cameras $makermodel }}

    {{/* Support is explicitly defined only if partial or non-existent, no news = good news */}}
    {{ $value := "<span class='badge rounded-circle text-bg-success square-badge'>✓</span>" }}
    {{ $try_libraw := false }}
    {{ with (index . "-supported") }}
      {{ if eq . "no" }}
        {{ $value = "<span class='badge rounded-circle text-bg-danger square-badge'>✗</span>" }}
        {{ $try_libraw = true }}
      {{ else if strings.Contains . "no-samples"}}
        {{ $value = "<span class='badge rounded-circle text-bg-warning square-badge'>?</span>" }}
        {{ $try_libraw = true }}
      {{ end }}
    {{ end }}

    {{/*
      In case Rawspeed doesn't support the camera×format, try to find if Libraw handles it.
      The caveat is Libraw doesn't reference cameras by the same name, and adds the possible hacky
      methods used, so we can only use a fuzzy search and hope that the results are consistent.
    */}}
    {{ if $try_libraw }}
      {{ range $libraw_cameras }}
        {{ $cam := index . 1 }}
        {{ if strings.Contains (upper $cam) (upper $makermodel) }}
          {{/* printf "%s : %s || \n\n" $cam $makermodel */}}
          {{ $value = "<span class='badge rounded-circle text-bg-info square-badge'>+</span>" }}
        {{ end }}
      {{ end }}
    {{ end }}

    {{/* We handle support for each mode/format */}}
    {{ $modes := $previous.mode }}
    {{ $current_mode := "Default format" }}
    {{ with (index . "-mode") }}
      {{ $current_mode = . }}
    {{ end }}
    {{ if $modes }}
      {{ $modes = printf "%s<br />%s %s" $modes $value $current_mode }}
    {{ else }}
      {{ $modes = printf "%s %s" $value $current_mode }}
    {{ end }}

    {{/*
        Aliases are a monkey business again.
        First, the are recalled in all camera objects, so there will be duplicates.
        Then, they can be defined as string, dictionnary, list of dictionnaries, or list of strings.
        Hugo doesn't have type checks so we need to use `printf "%T"` to find out what we are looking at.
    */}}
    {{ $aliases := $previous.aliases }}
    {{ with .Aliases }}
      {{ with .Alias }}
        {{ $list := slice }}

        {{/* Handle all possible types */}}
        {{ $type := printf "%T" . }}
        {{ if eq $type "string" }}<!-- string -->
          {{ $list = $list | append . }}
        {{ else if eq $type "map[string]interface {}" }}<!-- dictionnary -->
          {{ $list = $list | append (index . "-id") }}
        {{ else if eq $type "[]interface {}" }}<!-- list of something -->
          {{ range . }}
            {{ $ttype := printf "%T" . }}
            {{ if eq $ttype "string" }}<!-- something is a string -->
              {{ $list = $list | append . }}
            {{ else if eq $ttype "map[string]interface {}" }}<!-- something is a dictionnary -->
              {{ $list = $list | append (index . "-id") }}
            {{ end }}
          {{ end }}
        {{ else }}<!-- something else, not supported: will happen if Rawspeed changes its XML structure -->
          {{ errorf "The alias type %q is unsupported for element %s" $type . }}
        {{ end }}

        {{ if $aliases }}
          {{ $aliases = $aliases | append $list }}
        {{ else }}
          {{ $aliases = $list }}
        {{ end }}
      {{ end }}
    {{ end }}

    {{ $cameras = merge $cameras (dict $makermodel (dict "make" $maker "model" $model "mode" $modes "aliases" $aliases) ) }}
  {{ end }}
{{ end }}

{{ with $cameras }}
<table class="table table-striped table-hover w-100 full-width">
  <thead class="table-dark">
    <th>Maker</th><th>Model</th><th>Commercial aliases</th><th>Format / Supported</th>
  </thead>
  {{ range . }}
    <tr>
      <td>{{ index . "make" }}</td>
      <td>{{ index . "model" }}</td>
      <td>{{ delimit ( (index . "aliases") | uniq ) ", "  }}</td>
      <td>{{ index . "mode" | safeHTML}}</td>
    </tr>
  {{ end }}
</table>
{{ end }}
